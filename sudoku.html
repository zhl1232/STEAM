<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>数独挑战 - STEAM教育APP</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background-color: #f5f5f7;
            margin: 0;
            padding: 0;
            height: 100vh;
            overflow: hidden;
        }
        
        /* iOS状态栏 */
        .status-bar {
            background-color: #000;
            color: white;
            padding: 5px 15px;
            display: flex;
            justify-content: space-between;
            font-size: 14px;
            font-weight: 600;
        }
        
        /* 内容区域 */
        .content {
            height: calc(100vh - 130px);
            overflow-y: auto;
            padding-bottom: 70px;
        }
        
        /* 底部导航栏 */
        .tab-bar {
            position: fixed;
            bottom: 0;
            width: 100%;
            background-color: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(10px);
            display: flex;
            justify-content: space-around;
            padding: 10px 0;
            border-top: 1px solid #e5e5e5;
        }
        
        .tab-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            font-size: 10px;
            color: #8e8e93;
        }
        
        .tab-item.active {
            color: #007aff;
        }
        
        .tab-icon {
            font-size: 22px;
            margin-bottom: 3px;
        }
        
        /* 数独游戏样式 */
        .sudoku-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-top: 20px;
        }
        
        .sudoku-board {
            display: grid;
            grid-template-columns: repeat(9, 1fr);
            grid-gap: 1px;
            background-color: #333;
            border: 2px solid #333;
            width: 100%;
            max-width: 330px;
            aspect-ratio: 1/1;
            margin-bottom: 20px;
        }
        
        .sudoku-cell {
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: #fff;
            font-size: 18px;
            font-weight: bold;
            aspect-ratio: 1/1;
            cursor: pointer;
            user-select: none;
            position: relative;
        }
        
        .sudoku-cell.given {
            color: #333;
            background-color: #f0f0f0;
        }
        
        .sudoku-cell:not(.given) {
            color: #007aff;
        }
        
        .sudoku-cell.selected {
            background-color: #e6f7ff;
        }
        
        .sudoku-cell.related {
            background-color: #4aa2ee;
        }
        
        .sudoku-cell.error {
            color: #ff4d4f;
        }
        
        .sudoku-cell:nth-child(3n) {
            margin-right: 2px;
        }
        
        .sudoku-row:nth-child(3n) {
            margin-bottom: 2px;
        }
        
        .number-pad {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            grid-gap: 8px;
            width: 100%;
            max-width: 330px;
            margin-bottom: 20px;
        }
        
        .number-btn {
            background-color: #fff;
            border: 1px solid #ddd;
            border-radius: 8px;
            font-size: 18px;
            font-weight: bold;
            padding: 10px 0;
            cursor: pointer;
            text-align: center;
        }
        
        .number-btn:active {
            background-color: #e6f7ff;
        }
        
        .game-controls {
            display: flex;
            justify-content: space-between;
            width: 100%;
            max-width: 330px;
            margin-bottom: 20px;
        }
        
        .control-btn {
            background-color: #fff;
            border: 1px solid #ddd;
            border-radius: 8px;
            font-size: 14px;
            padding: 8px 16px;
            cursor: pointer;
        }
        
        .control-btn.primary {
            background-color: #007aff;
            color: #fff;
            border: none;
        }
        
        .difficulty-selector {
            display: flex;
            justify-content: space-between;
            width: 100%;
            max-width: 330px;
            margin-bottom: 20px;
        }
        
        .difficulty-btn {
            background-color: #fff;
            border: 1px solid #ddd;
            border-radius: 8px;
            font-size: 14px;
            padding: 8px 0;
            cursor: pointer;
            text-align: center;
            flex: 1;
            margin: 0 4px;
        }
        
        .difficulty-btn.active {
            background-color: #007aff;
            color: #fff;
            border: none;
        }
        
        .game-stats {
            display: flex;
            justify-content: space-between;
            width: 100%;
            max-width: 330px;
            margin-bottom: 20px;
        }
        
        .stat-box {
            background-color: #fff;
            border-radius: 8px;
            padding: 10px;
            text-align: center;
            flex: 1;
            margin: 0 4px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }
        
        /* 笔记样式 */
        .notes-container {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            width: 100%;
            height: 100%;
            font-size: 9px;
            color: #666;
            font-weight: normal;
        }
        
        .note {
            display: flex;
            align-items: center;
            justify-content: center;
        }
    </style>
</head>
<body>
    <!-- iOS状态栏 -->
    <div class="status-bar">
        <span>9:41</span>
        <div>
            <span class="mr-2"><i class="fas fa-signal"></i></span>
            <span class="mr-2"><i class="fas fa-wifi"></i></span>
            <span><i class="fas fa-battery-full"></i></span>
        </div>
    </div>
    
    <!-- 导航栏 -->
    <div class="bg-white p-4 flex items-center justify-between shadow-sm">
        <a href="mathematics.html" class="text-blue-500">
            <i class="fas fa-chevron-left mr-2"></i>返回
        </a>
        <h1 class="text-xl font-bold">数独挑战</h1>
        <i class="fas fa-question-circle text-gray-500"></i>
    </div>
    
    <!-- 内容区域 -->
    <div class="content p-4">
        <div class="sudoku-container">
            <!-- 游戏信息 -->
            <div class="game-stats">
                <div class="stat-box">
                    <div class="text-xs text-gray-500">时间</div>
                    <div class="text-lg font-bold" id="timer">00:00</div>
                </div>
                <div class="stat-box">
                    <div class="text-xs text-gray-500">难度</div>
                    <div class="text-lg font-bold" id="current-difficulty">中等</div>
                </div>
                <div class="stat-box">
                    <div class="text-xs text-gray-500">错误</div>
                    <div class="text-lg font-bold" id="error-count">0/3</div>
                </div>
            </div>
            
            <!-- 难度选择 -->
            <div class="difficulty-selector">
                <button class="difficulty-btn" data-difficulty="easy">简单</button>
                <button class="difficulty-btn active" data-difficulty="medium">中等</button>
                <button class="difficulty-btn" data-difficulty="hard">困难</button>
                <button class="difficulty-btn" data-difficulty="expert">专家</button>
            </div>
            
            <!-- 数独游戏板 -->
            <div class="sudoku-board" id="sudoku-board">
                <!-- 数独格子将由JavaScript动态生成 -->
            </div>
            
            <!-- 数字选择面板 -->
            <div class="number-pad">
                <button class="number-btn" data-number="1">1</button>
                <button class="number-btn" data-number="2">2</button>
                <button class="number-btn" data-number="3">3</button>
                <button class="number-btn" data-number="4">4</button>
                <button class="number-btn" data-number="5">5</button>
                <button class="number-btn" data-number="6">6</button>
                <button class="number-btn" data-number="7">7</button>
                <button class="number-btn" data-number="8">8</button>
                <button class="number-btn" data-number="9">9</button>
                <button class="number-btn" data-number="0">
                    <i class="fas fa-eraser"></i>
                </button>
            </div>
            
            <!-- 游戏控制 -->
            <div class="game-controls">
                <button class="control-btn" id="hint-btn">
                    <i class="fas fa-lightbulb mr-1"></i>提示
                </button>
                <button class="control-btn" id="undo-btn">
                    <i class="fas fa-undo mr-1"></i>撤销
                </button>
                <button class="control-btn" id="notes-btn">
                    <i class="fas fa-pencil-alt mr-1"></i>笔记
                </button>
                <button class="control-btn primary" id="new-game-btn">
                    <i class="fas fa-play mr-1"></i>新游戏
                </button>
            </div>
            
            <!-- 游戏提示 -->
            <div class="bg-blue-50 p-4 rounded-lg mb-4">
                <h3 class="text-sm font-bold text-blue-800 mb-2">如何玩数独？</h3>
                <p class="text-xs text-blue-700">
                    1. 每一行、每一列和每个3x3宫格必须包含数字1-9，不能重复。<br>
                    2. 游戏开始时，某些格子已经填有数字（灰色背景）。<br>
                    3. 你需要填写所有空白格子，遵循数独规则。<br>
                    4. 使用下方数字键盘填写数字，或点击"笔记"按钮记录可能的数字。
                </p>
            </div>
        </div>
    </div>
    
    <!-- 底部导航栏 -->
    <div class="tab-bar">
        <a href="home.html" class="tab-item">
            <div class="tab-icon"><i class="fas fa-home"></i></div>
            <div>首页</div>
        </a>
        <a href="science.html" class="tab-item">
            <div class="tab-icon"><i class="fas fa-flask"></i></div>
            <div>科学</div>
        </a>
        <a href="mathematics.html" class="tab-item active">
            <div class="tab-icon"><i class="fas fa-square-root-alt"></i></div>
            <div>数学</div>
        </a>
        <a href="community.html" class="tab-item">
            <div class="tab-icon"><i class="fas fa-users"></i></div>
            <div>社区</div>
        </a>
        <a href="profile.html" class="tab-item">
            <div class="tab-icon"><i class="fas fa-user"></i></div>
            <div>我的</div>
        </a>
    </div>

    <!-- JavaScript -->
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // 全局变量
            let selectedCell = null;
            let noteMode = false;
            let gameBoard = [];
            let solution = [];
            let startTime = null;
            let timerInterval = null;
            let errorCount = 0;
            let undoStack = [];
            let currentDifficulty = 'medium';
            let cellNotes = Array(9).fill().map(() => Array(9).fill().map(() => Array(9).fill(false)));
            
            // 事件监听器绑定标志，防止重复绑定
            let eventListenersInitialized = false;
            
            // 初始化游戏
            initializeGame();
            
            // 难度选择
            document.querySelectorAll('.difficulty-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    // 移除所有active类
                    document.querySelectorAll('.difficulty-btn').forEach(b => {
                        b.classList.remove('active');
                    });
                    // 添加active类到当前按钮
                    this.classList.add('active');
                    currentDifficulty = this.dataset.difficulty;
                    document.getElementById('current-difficulty').textContent = {
                        'easy': '简单',
                        'medium': '中等',
                        'hard': '困难',
                        'expert': '专家'
                    }[currentDifficulty];
                });
            });
            
            // 初始化游戏
            function initializeGame() {
                // 生成数独并显示
                generateSudoku();
                renderBoard();
                
                // 初始化笔记数组
                cellNotes = Array(9).fill().map(() => Array(9).fill().map(() => Array(9).fill(false)));
                
                // 仅在第一次初始化时添加事件监听器
                if (!eventListenersInitialized) {
                    // 添加事件监听器
                    document.getElementById('new-game-btn').addEventListener('click', startNewGame);
                    document.getElementById('hint-btn').addEventListener('click', giveHint);
                    document.getElementById('undo-btn').addEventListener('click', undoMove);
                    document.getElementById('notes-btn').addEventListener('click', toggleNoteMode);
                    
                    // 数字按钮事件 - 使用事件委托模式
                    const numberPad = document.querySelector('.number-pad');
                    numberPad.addEventListener('click', function(event) {
                        const target = event.target;
                        
                        // 确保点击的是数字按钮
                        if (target.classList.contains('number-btn') && selectedCell) {
                            const number = parseInt(target.dataset.number);
                            const num = isNaN(number) ? 0 : number;
                            
                            // 检查是否处于笔记模式且是有效数字
                            if (noteMode && num > 0) {
                                // 确保不是预设格子
                                if (!selectedCell.classList.contains('given')) {
                                    const row = parseInt(selectedCell.dataset.row);
                                    const col = parseInt(selectedCell.dataset.col);
                                    // 只有当单元格为空时才允许添加笔记
                                    if (gameBoard[row][col] === 0) {
                                        toggleNote(selectedCell, num);
                                    }
                                }
                            } else {
                                fillCell(selectedCell, num);
                            }
                        }
                    });
                    
                    // 标记事件监听器已初始化
                    eventListenersInitialized = true;
                }
                
                // 开始计时
                startTimer();
            }
            
            // 生成数独游戏
            function generateSudoku() {
                // 生成完整的已解决数独
                solution = generateSolvedSudoku();
                
                // 根据难度决定挖洞数量
                const holesCount = {
                    'easy': 30,
                    'medium': 40,
                    'hard': 50,
                    'expert': 60
                }[currentDifficulty];
                
                // 复制解决方案并挖洞
                gameBoard = JSON.parse(JSON.stringify(solution));
                digHoles(gameBoard, holesCount);
            }
            
            // 生成已解决的数独
            function generateSolvedSudoku() {
                // 创建一个空数独板
                const board = Array(9).fill().map(() => Array(9).fill(0));
                
                // 填充第一行为随机排列的1-9
                const firstRow = [1, 2, 3, 4, 5, 6, 7, 8, 9];
                shuffleArray(firstRow);
                board[0] = firstRow;
                
                // 使用回溯算法求解其余部分
                if (!solveSudoku(board)) {
                    // 如果求解失败，重新生成
                    return generateSolvedSudoku();
                }
                
                return board;
            }
            
            // 回溯法解数独 - 优化版本
            function solveSudoku(board) {
                const emptyCell = findEmptyCell(board);
                if (!emptyCell) {
                    return true; // 所有单元格已填满
                }
                
                const [row, col] = emptyCell;
                const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9];
                shuffleArray(numbers); // 随机尝试数字顺序，增加多样性
                
                for (let num of numbers) {
                    if (isValid(board, row, col, num)) {
                        board[row][col] = num;
                        
                        if (solveSudoku(board)) {
                            return true;
                        }
                        
                        board[row][col] = 0; // 回溯
                    }
                }
                
                return false; // 触发回溯
            }
            
            // 查找空单元格
            function findEmptyCell(board) {
                for (let row = 0; row < 9; row++) {
                    for (let col = 0; col < 9; col++) {
                        if (board[row][col] === 0) {
                            return [row, col];
                        }
                    }
                }
                return null; // 没有空单元格
            }
            
            // 检查在 (row, col) 位置放置数字 num 是否有效
            function isValid(board, row, col, num) {
                // 检查行
                for (let x = 0; x < 9; x++) {
                    if (board[row][x] === num) return false;
                }
                
                // 检查列
                for (let x = 0; x < 9; x++) {
                    if (board[x][col] === num) return false;
                }
                
                // 检查3x3方块
                const startRow = Math.floor(row / 3) * 3;
                const startCol = Math.floor(col / 3) * 3;
                
                for (let i = 0; i < 3; i++) {
                    for (let j = 0; j < 3; j++) {
                        if (board[i + startRow][j + startCol] === num) return false;
                    }
                }
                
                return true;
            }
            
            // 在数独板上挖洞 - 确保有唯一解
            function digHoles(board, count) {
                const positions = [];
                for (let row = 0; row < 9; row++) {
                    for (let col = 0; col < 9; col++) {
                        positions.push([row, col]);
                    }
                }
                
                // 随机排序位置
                shuffleArray(positions);
                
                let holes = 0;
                for (const [row, col] of positions) {
                    const temp = board[row][col];
                    board[row][col] = 0;
                    
                    // 简单检查是否仍然有唯一解 - 此处可以进一步优化
                    if (hasUniqueSolution(board)) {
                        holes++;
                        if (holes >= count) {
                            break;
                        }
                    } else {
                        // 如果没有唯一解，恢复单元格
                        board[row][col] = temp;
                    }
                }
            }
            
            // 简单检查数独是否有唯一解
            // 注意：完整的唯一性检查非常复杂和耗时，这里使用简化版本
            function hasUniqueSolution(board) {
                // 简化方法：确保每行、每列和每个3x3宫格中至少有一些数字填充
                // 这不是完美的唯一性检查，但对于大多数情况够用
                
                // 检查每行
                for (let row = 0; row < 9; row++) {
                    let filledCount = 0;
                    for (let col = 0; col < 9; col++) {
                        if (board[row][col] !== 0) filledCount++;
                    }
                    if (filledCount < 3) return false; // 至少需要3个数字
                }
                
                // 检查每列
                for (let col = 0; col < 9; col++) {
                    let filledCount = 0;
                    for (let row = 0; row < 9; row++) {
                        if (board[row][col] !== 0) filledCount++;
                    }
                    if (filledCount < 3) return false; // 至少需要3个数字
                }
                
                // 检查每个3x3宫格
                for (let blockRow = 0; blockRow < 3; blockRow++) {
                    for (let blockCol = 0; blockCol < 3; blockCol++) {
                        let filledCount = 0;
                        for (let i = 0; i < 3; i++) {
                            for (let j = 0; j < 3; j++) {
                                const row = blockRow * 3 + i;
                                const col = blockCol * 3 + j;
                                if (board[row][col] !== 0) filledCount++;
                            }
                        }
                        if (filledCount < 3) return false; // 至少需要3个数字
                    }
                }
                
                return true;
            }
            
            // 渲染数独板
            function renderBoard() {
                const boardElement = document.getElementById('sudoku-board');
                boardElement.innerHTML = '';
                
                for (let row = 0; row < 9; row++) {
                    for (let col = 0; col < 9; col++) {
                        const cell = document.createElement('div');
                        cell.className = 'sudoku-cell';
                        cell.dataset.row = row;
                        cell.dataset.col = col;
                        
                        const value = gameBoard[row][col];
                        if (value !== 0) {
                            cell.textContent = value;
                            cell.classList.add('given');
                        } else {
                            // 检查是否有笔记
                            const notesForCell = cellNotes[row][col];
                            if (notesForCell.some(note => note)) {
                                renderNotes(cell, notesForCell);
                            }
                        }
                        
                        // 添加点击事件
                        cell.addEventListener('click', function() {
                            // 移除先前选中的单元格和相关单元格的高亮
                            if (selectedCell) {
                                selectedCell.classList.remove('selected');
                                // 移除所有相关单元格高亮
                                document.querySelectorAll('.sudoku-cell.related').forEach(cell => {
                                    cell.classList.remove('related');
                                });
                            }
                            
                            // 选中当前单元格
                            this.classList.add('selected');
                            selectedCell = this;
                            
                            // 高亮相关行、列和宫格
                            highlightRelatedCells(parseInt(this.dataset.row), parseInt(this.dataset.col));
                        });
                        
                        boardElement.appendChild(cell);
                    }
                }
            }
            
            // 渲染单元格的笔记
            function renderNotes(cell, notes) {
                // 清空单元格内容
                cell.innerHTML = '';
                
                // 创建笔记容器
                const notesContainer = document.createElement('div');
                notesContainer.className = 'notes-container';
                
                // 添加9个笔记位置
                for (let i = 0; i < 9; i++) {
                    const note = document.createElement('div');
                    note.className = 'note';
                    note.textContent = notes[i] ? (i + 1) : '';
                    notesContainer.appendChild(note);
                }
                
                // 将笔记容器添加到单元格
                cell.appendChild(notesContainer);
                
                // 输出调试信息
                console.log('渲染笔记:', notes);
            }
            
            // 切换笔记模式
            function toggleNoteMode() {
                noteMode = !noteMode;
                const notesBtn = document.getElementById('notes-btn');
                
                if (noteMode) {
                    notesBtn.classList.add('primary');
                    // 可选：添加一个提示信息
                    console.log('笔记模式已启用');
                } else {
                    notesBtn.classList.remove('primary');
                    console.log('笔记模式已禁用');
                }
            }
            
            // 切换笔记
            function toggleNote(cell, number) {
                const row = parseInt(cell.dataset.row);
                const col = parseInt(cell.dataset.col);
                
                // 如果是预设的数字，不允许添加笔记
                if (cell.classList.contains('given') || gameBoard[row][col] !== 0) {
                    return;
                }
                
                // 保存当前状态到撤销栈
                undoStack.push({
                    row: row,
                    col: col,
                    prevNotes: [...cellNotes[row][col]],
                    isNote: true
                });
                
                // 切换笔记
                cellNotes[row][col][number - 1] = !cellNotes[row][col][number - 1];
                
                // 更新UI
                renderNotes(cell, cellNotes[row][col]);
                
                // 输出调试信息
                console.log(`在 (${row}, ${col}) 位置切换数字 ${number} 的笔记状态`);
                console.log(cellNotes[row][col]);
            }
            
            // 填充单元格
            function fillCell(cell, number) {
                const row = parseInt(cell.dataset.row);
                const col = parseInt(cell.dataset.col);
                
                // 如果是预设的数字，不允许修改
                if (cell.classList.contains('given')) {
                    return;
                }
                
                // 保存当前状态到撤销栈
                undoStack.push({
                    row: row,
                    col: col,
                    prevValue: gameBoard[row][col],
                    prevNotes: [...cellNotes[row][col]],
                    isNote: false
                });
                
                // 填充数字
                gameBoard[row][col] = number;
                
                // 清空笔记
                cellNotes[row][col] = Array(9).fill(false);
                
                if (number === 0) {
                    cell.textContent = '';
                    cell.innerHTML = ''; // 确保笔记也被清除
                    cell.classList.remove('error');
                } else {
                    cell.innerHTML = ''; // 清除可能的笔记
                    cell.textContent = number;
                    
                    // 检查是否正确
                    if (number !== solution[row][col]) {
                        cell.classList.add('error');
                        errorCount++;
                        document.getElementById('error-count').textContent = `${errorCount}/3`;
                        
                        // 如果错误次数达到3次，游戏结束
                        if (errorCount >= 3) {
                            setTimeout(() => {
                                alert('游戏失败！你已经犯了3次错误。');
                                startNewGame();
                            }, 100);
                        }
                    } else {
                        cell.classList.remove('error');
                        
                        // 检查游戏是否完成
                        checkGameCompletion();
                    }
                }
            }
            
            // 提供提示
            function giveHint() {
                if (!selectedCell || selectedCell.classList.contains('given')) {
                    return;
                }
                
                const row = parseInt(selectedCell.dataset.row);
                const col = parseInt(selectedCell.dataset.col);
                
                // 保存当前状态到撤销栈
                undoStack.push({
                    row: row,
                    col: col,
                    prevValue: gameBoard[row][col],
                    prevNotes: [...cellNotes[row][col]],
                    isNote: false
                });
                
                // 填入正确答案
                gameBoard[row][col] = solution[row][col];
                
                // 清空笔记
                cellNotes[row][col] = Array(9).fill(false);
                
                selectedCell.innerHTML = ''; // 清除笔记
                selectedCell.textContent = solution[row][col];
                selectedCell.classList.add('given'); // 提示值也标记为given以使用相同的颜色样式
                selectedCell.classList.remove('error');
                
                // 检查游戏是否完成
                checkGameCompletion();
            }
            
            // 撤销上一步操作
            function undoMove() {
                if (undoStack.length === 0) {
                    return;
                }
                
                const lastMove = undoStack.pop();
                const { row, col, prevValue, prevNotes, isNote } = lastMove;
                
                // 获取单元格
                const cell = document.querySelector(`.sudoku-cell[data-row="${row}"][data-col="${col}"]`);
                
                if (isNote) {
                    // 恢复笔记
                    cellNotes[row][col] = [...prevNotes];
                    
                    // 更新UI
                    if (prevNotes.some(note => note)) {
                        renderNotes(cell, prevNotes);
                    } else {
                        cell.innerHTML = '';
                    }
                } else {
                    // 恢复值和笔记
                    gameBoard[row][col] = prevValue;
                    cellNotes[row][col] = [...prevNotes];
                    
                    // 更新UI
                    cell.classList.remove('error', 'given');
                    
                    if (prevValue === 0) {
                        // 检查是否有笔记
                        if (prevNotes.some(note => note)) {
                            renderNotes(cell, prevNotes);
                        } else {
                            cell.innerHTML = '';
                        }
                    } else {
                        cell.innerHTML = '';
                        cell.textContent = prevValue;
                    }
                }
            }
            
            // 开始新游戏
            function startNewGame() {
                // 重置状态
                selectedCell = null;
                noteMode = false;
                errorCount = 0;
                undoStack = [];
                
                // 清除所有高亮
                document.querySelectorAll('.sudoku-cell.related').forEach(cell => {
                    cell.classList.remove('related');
                });
                
                // 重置笔记模式按钮
                document.getElementById('notes-btn').classList.remove('primary');
                
                // 停止旧计时器
                clearInterval(timerInterval);
                
                // 更新错误计数
                document.getElementById('error-count').textContent = '0/3';
                
                // 初始化新游戏 - 不会重复添加事件监听器
                initializeGame();
            }
            
            // 检查游戏是否完成
            function checkGameCompletion() {
                for (let row = 0; row < 9; row++) {
                    for (let col = 0; col < 9; col++) {
                        if (gameBoard[row][col] === 0 || gameBoard[row][col] !== solution[row][col]) {
                            return false;
                        }
                    }
                }
                
                // 游戏完成
                clearInterval(timerInterval);
                const timeSpent = document.getElementById('timer').textContent;
                setTimeout(() => {
                    alert(`恭喜！你成功完成了数独挑战！\n用时：${timeSpent}\n错误次数：${errorCount}`);
                }, 100);
                
                return true;
            }
            
            // 开始计时器
            function startTimer() {
                startTime = Date.now();
                
                // 清除旧定时器
                if (timerInterval) {
                    clearInterval(timerInterval);
                }
                
                // 设置新定时器
                timerInterval = setInterval(updateTimer, 1000);
                updateTimer();
            }
            
            // 更新计时器
            function updateTimer() {
                const elapsedSeconds = Math.floor((Date.now() - startTime) / 1000);
                const minutes = Math.floor(elapsedSeconds / 60).toString().padStart(2, '0');
                const seconds = (elapsedSeconds % 60).toString().padStart(2, '0');
                document.getElementById('timer').textContent = `${minutes}:${seconds}`;
            }
            
            // 辅助函数：打乱数组
            function shuffleArray(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
                return array;
            }
            
            // 高亮相关的行、列和宫格
            function highlightRelatedCells(row, col) {
                const cells = document.querySelectorAll('.sudoku-cell');
                
                cells.forEach(cell => {
                    const cellRow = parseInt(cell.dataset.row);
                    const cellCol = parseInt(cell.dataset.col);
                    
                    // 同一行
                    if (cellRow === row && cellCol !== col) {
                        cell.classList.add('related');
                    }
                    // 同一列
                    else if (cellCol === col && cellRow !== row) {
                        cell.classList.add('related');
                    }
                    // 同一宫格 (3x3方块)
                    else if (
                        Math.floor(cellRow / 3) === Math.floor(row / 3) && 
                        Math.floor(cellCol / 3) === Math.floor(col / 3) && 
                        !(cellRow === row && cellCol === col)
                    ) {
                        cell.classList.add('related');
                    }
                });
            }
        });
    </script>
</body>
</html> 